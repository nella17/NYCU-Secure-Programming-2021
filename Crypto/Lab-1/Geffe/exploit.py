import itertools
import hashlib
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

class LFSR:
    def __init__(self, key, taps):
        d = max(taps)
        assert len(key) == d, "Error: key of wrong size."
        self._s = key
        self._t = [d - t for t in taps]

    def _sum(self, L):
        s = 0
        for x in L:
            s ^= x
        return s

    def _clock(self):
        b = self._s[0]
        self._s = self._s[1:] + [self._sum(self._s[p] for p in self._t)]
        return b

    def getbit(self):
        return self._clock()

stream = [0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1]
iv = bytes.fromhex('cd2832f408d1d973be28b66b133a0b5f')
encrypted_flag = bytes.fromhex('1e3c272c4d9693580659218739e9adace2c5daf98062cf892cf6a9d0fc465671f8cd70a139b384836637c131217643c1')

tapses = [
    [19, 18, 17, 14],
    [27, 26, 25, 22],
    [23, 22, 20, 18],
]

key = [None] * len(tapses)

for k in range(1,3):
    key_len = max(tapses[k])
    for b in range(key_len):
        print(k, b)
        for c in itertools.combinations(range(key_len), b):
            key_condidate = [1 - stream[i] if i in c else stream[i] for i in range(key_len)]
            lfsr = LFSR(key_condidate, tapses[k])
            matches = sum(x == lfsr.getbit() for x in stream)
            if matches >= len(stream) * 0.7:
                print(k, key_condidate)
                key[k] = key_condidate
                break
        if key[k]: break

taps = tapses[0]
L = max(taps)
for i in range(2**L):
    key[0] = [int(i) for i in list(f"{{:0{L}b}}".format(i))]
    rng = [LFSR(k,t) for k,t in zip(key,tapses)]
    match = True
    for x in stream:
        b = [lfsr.getbit() for lfsr in rng]
        y = b[1] if b[0] else b[2]
        match = x == y
        if not match: break
    if match:
        print(key[0])
        break

key = sum(key, [])
key = ''.join(map(str, key))
key = int(key, 2)

print(key)

key = hashlib.sha1(str(key).encode('ascii')).digest()[:16]
cipher = AES.new(key, AES.MODE_CBC, iv)
flag = unpad(cipher.decrypt(encrypted_flag), 16).decode()

print(flag)

